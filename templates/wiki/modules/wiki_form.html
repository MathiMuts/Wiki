{% extends "./wiki_base.html" %}
{% block title%}{% if page %}{{ page.title }}{% else %}{{ action }} Page{% endif %} - Wiki{% endblock %}
{% load static %}
{% block content %}
    <h1>{{ action }} Wiki Page{% if page %}: <strong class="page-meta">{{ page.title }}</strong>{% endif %}</h1>
    
    <form method="post" id="wikiPageForm" action=""> 
        {% csrf_token %}

        {% if page %}
            <input type="hidden" id="original_slug" value="{{ page.slug }}">
        {% endif %}

        <div class="form-row-responsive">
            <div class="form-group form-group-responsive">
                <label for="{{ form.title.id_for_label }}">Title:</label>
                {{ form.title }}
                {% if form.title.errors %}
                    <div class="form-field-error">{{ form.title.errors|join:", " }}</div>
                {% endif %}
            </div>

            <div class="form-group form-group-responsive">
                <label for="{{ form.slug.id_for_label }}">Slug (URL Path):</label>
                {{ form.slug }}
                {% if form.slug.errors %}
                    <div class="slug-error">
                        <strong>Error:</strong> {{ form.slug.errors|join:", " }}
                    </div>
                {% endif %}
                <div id="slugChangeWarning" class="slug-warning" style="display: none;">
                    <strong>Important:</strong> Changing the slug alters the page's web address. 
                    Any existing links or bookmarks pointing to the old address will no longer work.
                </div>
                <div id="slugNotEmptyWarning" class="slug-warning" style="display: none;">
                    <strong>Note:</strong> The slug determines the page's URL. If you set a custom slug, changing it later can break links.
                    Leave blank to auto-generate from title.
                </div>
            </div>
        </div>

        <div class="form-group">
            <label for="{{ form.content.id_for_label }}">Content (Markdown):</label>
            {{ form.content }}
        </div>
        <p><small>Use Markdown for formatting. <a href="https://www.markdownguide.org/basic-syntax/" target="_blank">Markdown Guide</a></small></p>
        
        <div class="actions edit-buttons">
            <div>
                <button type="submit" class="edit"> 
                    {% if action == 'Create' %}Create Page{% else %}Save Changes{% endif %}
                </button>
                <a href="{% if page %}{{ page.get_absolute_url }}{% else %}{% url 'wiki:wiki' %}{% endif %}" class="button-link cancel">Cancel</a>
            </div>
    </form> 

            {% if page and action == 'Edit' %}
            <form action="{% url 'wiki:page_delete' page.slug %}" method="post" style="display: inline; margin: 0;" id="deleteForm">
                {% csrf_token %}
                <button type="button" class="delete hold-to-delete-btn" id="deleteBtn" 
                        data-default-text="Delete This Page" 
                        data-holding-text="Hold to Delete..." 
                        data-ready-text="Release to Delete!">
                    <span class="btn-text">Delete This Page</span>
                    <span class="progress-fill"></span>
                </button>
            </form>
            {% endif %}
        </div>


    {% if page %} 
    <hr style="margin: 40px 0 20px 0;">
    <div class="wiki-attachments section-card-plain">
        <h2>Attached Files <span id="deleteStatusMessage" style="margin-left: 10px; font-size: 0.6em; font-weight: normal;"></span></h2>
        <ul class="file-list" id="fileListContainer">
            {% for file_attachment in page_files %}
                <li class="file-item" id="file-item-{{ file_attachment.id }}" data-filename-slug="{{ file_attachment.filename_slug }}">
                    <a href="{{ file_attachment.file.url }}" target="_blank" class="file-link">{{ file_attachment.filename_display }}</a>
                    <small class="file-meta">
                        Uploaded on {{ file_attachment.uploaded_at|date:"M d, Y H:i" }}
                        {% if file_attachment.uploaded_by %}
                            by {{ file_attachment.uploaded_by.username }}
                        {% endif %}
                    </small>
                    {% if user.is_authenticated %}
                        <button type="button" class="button-danger-small file-delete-btn" 
                                data-file-id="{{ file_attachment.id }}" 
                                data-delete-url="{% url 'wiki:page_delete_file' page.slug file_attachment.id %}">
                            Delete
                        </button>
                    {% endif %}
                </li>
            {% endfor %}
        </ul>
        <p id="noFilesMessage" style="display: {% if not page_files %}block{% else %}none{% endif %};">No files attached to this page yet.</p>

        {% if user.is_authenticated and upload_form %}
            <div class="upload-section">
                <h2 style="margin-top: 20px;">Upload New File <span id="uploadStatusMessage" style="margin-left: 10px; font-size: 0.6em; font-weight: normal;"></span></h2>
                <form id="fileUploadForm" enctype="multipart/form-data" class="upload-form actions">
                    <div class="form-row-responsive file-upload-row"> 
                        <div class="form-group form-group-responsive">
                            <label for="{{ upload_form.file.id_for_label }}">{{ upload_form.file.label }}:</label>
                            {{ upload_form.file }} 
                            <div class="form-field-error" id="fileUploadError_file" style="display:none;"></div>
                            {% if upload_form.file.help_text %}
                                <small class="form-text text-muted">{{ upload_form.file.help_text|safe }}</small>
                            {% endif %}
                        </div>

                        <div class="form-group form-group-responsive">
                            <label for="{{ upload_form.filename_slug.id_for_label }}">{{ upload_form.filename_slug.label }}:</label>
                            {{ upload_form.filename_slug }} 
                            <small class="form-text text-muted" id="filenameSlugHelpText">
                                {% if upload_form.filename_slug.help_text %}{{ upload_form.filename_slug.help_text|safe }}{% endif %}
                            </small>
                            <div class="form-field-error" id="fileUploadError_filename_slug" style="display:none;"></div>
                        </div>
                    </div>
                    
                    <button type="submit" class="edit" style="margin-top:10px;" id="uploadFileBtn">Upload File</button>
                </form>
            </div>
        {% endif %}
    </div>
    {% else %} 
     <hr style="margin: 40px 0 20px 0;">
        <div class="wiki-attachments section-card-plain">
        <h2>Attached Files</h2>
        <p>Create the page first to upload files.</p> 
        </div>
    {% endif %}

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        const contentTextarea = document.getElementById('wiki-form-content-textarea');
        if (contentTextarea) {
            let previousValue = contentTextarea.value;
            let previousCursorPos = contentTextarea.selectionStart;
            function getTrailingEmptyLineCount(text) { if (!text) return 0; const lines = text.split('\n'); let count = 0; for (let i = lines.length - 1; i >= 0; i--) { if (lines[i].trim() === "") { count++; } else { break; } } return count; }
            function autoResizeAndManageLines(event = null) {
                const DESIRED_MINIMUM_TRAILING_EMPTY_LINES = 3;
                const currentValue = contentTextarea.value;
                const currentCursorPos = contentTextarea.selectionStart;
                let newCursorPos = currentCursorPos;
                let valueToProcess = currentValue;
                const savedScrollY = window.scrollY;
                const savedScrollX = window.scrollX;
                const existingTrailing = getTrailingEmptyLineCount(valueToProcess);
                const linesToAdd = DESIRED_MINIMUM_TRAILING_EMPTY_LINES - existingTrailing;

                if (linesToAdd > 0) {
                    const originalLengthBeforeAddingLines = valueToProcess.length;
                    for (let i = 0; i < linesToAdd; i++) { valueToProcess += '\n'; }
                    if (currentValue.length < valueToProcess.length && currentCursorPos === originalLengthBeforeAddingLines) {
                        newCursorPos = originalLengthBeforeAddingLines;
                    }
                }

                if (contentTextarea.value !== valueToProcess) {
                    contentTextarea.value = valueToProcess;
                }
                contentTextarea.style.height = 'auto';
                contentTextarea.style.height = (contentTextarea.scrollHeight) + 'px';

                if (event || (valueToProcess.length !== currentValue.length && !event) ) {
                    if (event && event.inputType === 'insertLineBreak') { /* Potentially special handling */ }
                    try {
                        const textLength = contentTextarea.value.length;
                        if (newCursorPos > textLength) { newCursorPos = textLength; }
                        if (contentTextarea.selectionStart !== newCursorPos || contentTextarea.selectionEnd !== newCursorPos) {
                           contentTextarea.setSelectionRange(newCursorPos, newCursorPos);
                        }
                    } catch (e) {
                        const endPos = contentTextarea.value.length;
                        try { contentTextarea.setSelectionRange(endPos, endPos); } catch (e2) { /* ignore secondary error */ }
                    }
                }
                previousValue = contentTextarea.value;
                previousCursorPos = contentTextarea.selectionStart;
                Promise.resolve().then(() => {
                    if (window.scrollY !== savedScrollY || window.scrollX !== savedScrollX) {
                        window.scrollTo(savedScrollX, savedScrollY);
                    }
                });
            }
            autoResizeAndManageLines();
            previousValue = contentTextarea.value;
            previousCursorPos = contentTextarea.selectionStart;
            contentTextarea.addEventListener('input', autoResizeAndManageLines);
        }

        const deleteBtn = document.getElementById('deleteBtn');
        const deleteForm = document.getElementById('deleteForm');

        if (deleteBtn && deleteForm) {
            const HOLD_DURATION_PAGE = 5000;
            let pageActionTimeoutId = null;
            let pageAnimationFrameId = null;
            let isHoldingPageDelete = false;

            const progressFillSpan = deleteBtn.querySelector('.progress-fill');
            const btnTextSpan = deleteBtn.querySelector('.btn-text');
            const defaultText = deleteBtn.dataset.defaultText || 'Delete This Page';
            const holdingText = deleteBtn.dataset.holdingText || 'Hold to Delete...';
            const readyText = deleteBtn.dataset.readyText || 'Release to Delete!';

            const setButtonText = (textKey) => {
                if (!btnTextSpan) return;
                if (textKey === 'default') btnTextSpan.textContent = defaultText;
                else if (textKey === 'holding') btnTextSpan.textContent = holdingText;
                else if (textKey === 'ready') btnTextSpan.textContent = readyText;
            };
            setButtonText('default');

            const resetPageHoldState = (performNudge = false) => {
                clearTimeout(pageActionTimeoutId);
                cancelAnimationFrame(pageAnimationFrameId);
                pageActionTimeoutId = null;
                pageAnimationFrameId = null;
                deleteBtn.classList.remove('is-filling', 'is-ready-to-delete');
                setButtonText('default');
                
                const wasHolding = isHoldingPageDelete;
                isHoldingPageDelete = false;

                if (performNudge && progressFillSpan && wasHolding) {
                    progressFillSpan.style.transition = 'none';
                    progressFillSpan.style.width = '15%';
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            progressFillSpan.style.transition = 'width 0.3s ease-out';
                            progressFillSpan.style.width = '0%';
                        });
                    });
                } else if (progressFillSpan) {
                    progressFillSpan.style.transition = 'width 0.1s linear';
                    progressFillSpan.style.width = '0%';
                }
            };

            const startPageHold = (event) => {
                event.preventDefault();
                if (isHoldingPageDelete) return;
                isHoldingPageDelete = true;

                deleteBtn.classList.add('is-filling');
                if (progressFillSpan) {
                    progressFillSpan.style.transition = 'none';
                    progressFillSpan.style.width = '0%';
                }
                setButtonText('holding');

                const startTime = Date.now();
                function animatePageFill() {
                    if (!isHoldingPageDelete) {
                        cancelAnimationFrame(pageAnimationFrameId);
                        return;
                    }
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(100, (elapsedTime / HOLD_DURATION_PAGE) * 100);
                    if (progressFillSpan) progressFillSpan.style.width = progress + '%';

                    if (elapsedTime < HOLD_DURATION_PAGE) {
                        pageAnimationFrameId = requestAnimationFrame(animatePageFill);
                    } else {
                        if (!deleteBtn.classList.contains('is-ready-to-delete')) {
                            deleteBtn.classList.add('is-ready-to-delete');
                            setButtonText('ready');
                        }
                    }
                }
                pageAnimationFrameId = requestAnimationFrame(animatePageFill);

                pageActionTimeoutId = setTimeout(() => {
                    if (isHoldingPageDelete) {
                        deleteBtn.classList.add('is-ready-to-delete');
                        setButtonText('ready');
                    }
                }, HOLD_DURATION_PAGE);
            };

            const endPageHold = (isReleasedOnButtonContext) => {
                if (!isHoldingPageDelete) return;

                const wasReadyForDelete = deleteBtn.classList.contains('is-ready-to-delete');
                const currentlyWasHolding = isHoldingPageDelete;

                if (isReleasedOnButtonContext && wasReadyForDelete) {
                    isHoldingPageDelete = false;
                    if (confirm('Are you sure you want to delete this page: \'{{ page.title|escapejs }}\'? This action cannot be undone.')) {
                        deleteForm.submit();
                        return; 
                    } else {
                        resetPageHoldState(false); 
                    }
                } else if (isReleasedOnButtonContext && !wasReadyForDelete && currentlyWasHolding) {
                    resetPageHoldState(true); 
                } else {
                    resetPageHoldState(false); 
                }
            };
            
            deleteBtn.addEventListener('mousedown', startPageHold);
            deleteBtn.addEventListener('touchstart', (e) => startPageHold(e), { passive: false });
            
            deleteBtn.addEventListener('mouseleave', () => { if(isHoldingPageDelete && event.buttons === 1) resetPageHoldState(false); });
            deleteBtn.addEventListener('touchcancel', () => { if(isHoldingPageDelete) resetPageHoldState(false); });
            deleteBtn.addEventListener('blur', () => { if(isHoldingPageDelete) resetPageHoldState(false); });
            
            document.addEventListener('mouseup', (event) => {
                if (isHoldingPageDelete) {
                    const isReleasedOnButton = event.target === deleteBtn || deleteBtn.contains(event.target);
                    endPageHold(isReleasedOnButton);
                }
            });
            document.addEventListener('touchend', (event) => {
                 if (isHoldingPageDelete) {
                    let isReleasedOnButton = false;
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        const touch = event.changedTouches[i];
                        const endTarget = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (endTarget === deleteBtn || deleteBtn.contains(endTarget)) {
                            isReleasedOnButton = true;
                            break;
                        }
                    }
                    endPageHold(isReleasedOnButton);
                }
            });
        }

        const fileUploadForm = document.getElementById('fileUploadForm');
        const fileListContainer = document.getElementById('fileListContainer');
        const noFilesMessage = document.getElementById('noFilesMessage');
        const uploadStatusMessage = document.getElementById('uploadStatusMessage');
        const deleteStatusMessage = document.getElementById('deleteStatusMessage');
        
        const fileInput = document.getElementById('{{ upload_form.file.id_for_label }}'); 
        const filenameSlugInput = document.getElementById('{{ upload_form.filename_slug.id_for_label }}');
        const filenameSlugHelpText = document.getElementById('filenameSlugHelpText');

        function getCsrfToken() {
            const csrfInput = document.querySelector('#wikiPageForm input[name="csrfmiddlewaretoken"]');
            return csrfInput ? csrfInput.value : null;
        }

        function slugify_js(text) {
            if (!text) return '';
            return text.toString().toLowerCase()
                .replace(/\s+/g, '-') .replace(/[^\w-]+/g, '').replace(/--+/g, '-')
                .replace(/^-+/, '').replace(/-+$/, '');
        }

        function generateUniqueFilenameSlug(originalName) {
            if (!originalName) return "";
            const nameParts = originalName.split('.');
            const extension = nameParts.length > 1 ? '.' + nameParts.pop() : '';
            const nameWithoutExt = nameParts.join('.');
            let baseSlug = slugify_js(nameWithoutExt) || 'file';
            const existingSlugs = [];
            if (fileListContainer) {
                fileListContainer.querySelectorAll('li.file-item').forEach(item => {
                    if (item.dataset.filenameSlug) existingSlugs.push(item.dataset.filenameSlug);
                });
            }
            let finalSlug = baseSlug;
            let counter = 1;
            while (existingSlugs.includes(finalSlug)) {
                finalSlug = `${baseSlug}_${counter}`;
                counter++;
            }
            return finalSlug;
        }

        if (fileInput && filenameSlugInput) { 
            fileInput.addEventListener('change', function() {
                if (this.files && this.files[0]) {
                    const originalFilenameForSlug = this.files[0].name;
                    const generatedSlug = generateUniqueFilenameSlug(originalFilenameForSlug);
                    filenameSlugInput.value = generatedSlug;
                    if(filenameSlugHelpText) filenameSlugHelpText.textContent = "Auto-generated. This will be the base name of your file.";
                } else {
                    filenameSlugInput.value = '';
                    if(filenameSlugHelpText) filenameSlugHelpText.textContent = "{% if upload_form.filename_slug.help_text %}{{ upload_form.filename_slug.help_text|safe }}{% else %}Auto-generated from filename.{% endif %}";
                }
            });
        }

        if (fileUploadForm) { 
             fileUploadForm.addEventListener('submit', function(event) {
                event.preventDefault();
                if (uploadStatusMessage) {
                    uploadStatusMessage.textContent = 'Uploading...';
                    uploadStatusMessage.style.color = 'inherit';
                }
                
                const fileErrorEl = document.getElementById('fileUploadError_file');
                const slugErrorEl = document.getElementById('fileUploadError_filename_slug');
                if(fileErrorEl) { fileErrorEl.textContent = ''; fileErrorEl.style.display = 'none'; }
                if(slugErrorEl) { slugErrorEl.textContent = ''; slugErrorEl.style.display = 'none'; }

                const formData = new FormData(fileUploadForm);
                const csrfToken = getCsrfToken(); 
                if (!csrfToken) { 
                    if (uploadStatusMessage) {
                        uploadStatusMessage.textContent = 'Error: CSRF token missing for AJAX upload.';
                        uploadStatusMessage.style.color = 'red';
                    }
                    return; 
                }
                const uploadUrl = "{% if page %}{% url 'wiki:page_upload_file' page.slug %}{% endif %}";
                if (!uploadUrl) {
                    if (uploadStatusMessage) {
                        uploadStatusMessage.textContent = 'Error: Cannot determine upload URL.';
                        uploadStatusMessage.style.color = 'red';
                    }
                    return;
                }
                fetch(uploadUrl, { method: 'POST', body: formData, headers: { 'X-CSRFToken': csrfToken } })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        if (uploadStatusMessage) {
                            uploadStatusMessage.textContent = data.message;
                            uploadStatusMessage.style.color = 'green';
                        }
                        fileUploadForm.reset(); 
                        if(filenameSlugInput) filenameSlugInput.value = '';
                        if(filenameSlugHelpText) filenameSlugHelpText.textContent = "{% if upload_form.filename_slug.help_text %}{{ upload_form.filename_slug.help_text|safe }}{% else %}Auto-generated from filename.{% endif %}";

                        const newFile = data.file;
                        const li = document.createElement('li');
                        li.classList.add('file-item');
                        li.id = `file-item-${newFile.id}`;
                        li.dataset.filenameSlug = newFile.filename_slug_stored;
                        li.innerHTML = `
                            <a href="${newFile.url}" target="_blank" class="file-link">${newFile.name}</a>
                            <small class="file-meta">
                                Uploaded on ${newFile.uploaded_at_display}
                                ${newFile.uploaded_by_username ? `by ${newFile.uploaded_by_username}` : ''}
                            </small>
                            <button type="button" class="button-danger-small file-delete-btn" 
                                    data-file-id="${newFile.id}" 
                                    data-delete-url="${newFile.delete_url}">
                                Delete
                            </button>
                        `;
                        if (fileListContainer) fileListContainer.appendChild(li);
                        if (noFilesMessage) noFilesMessage.style.display = 'none';
                        li.querySelector('.file-delete-btn').addEventListener('click', handleDeleteFileEvent);
                    } else { 
                        if (uploadStatusMessage) {
                            uploadStatusMessage.textContent = data.message || 'Upload failed.';
                            uploadStatusMessage.style.color = 'red';
                        }
                        if (data.errors) {
                            for (const field in data.errors) {
                                const errorEl = document.getElementById(`fileUploadError_${field}`);
                                if (errorEl) {
                                    errorEl.textContent = data.errors[field].join(', ');
                                    errorEl.style.display = 'block';
                                }
                            }
                        }
                    }
                })
                .catch(error => { 
                    if (uploadStatusMessage) {
                        uploadStatusMessage.textContent = 'Network error during upload.';
                        uploadStatusMessage.style.color = 'red';
                    }
                })
                .finally(() => { 
                    if (uploadStatusMessage) {
                        setTimeout(() => { if(uploadStatusMessage) uploadStatusMessage.textContent = ''; }, 5000); 
                    }
                });
            });
        }

        function handleDeleteFileEvent(event) {
            const button = event.target;
            const fileId = button.dataset.fileId;
            const deleteUrl = button.dataset.deleteUrl;
            if (!confirm('Are you sure you want to delete this file? This action cannot be undone.')) return;
            
            if (deleteStatusMessage) {
                deleteStatusMessage.textContent = 'Deleting...';
                deleteStatusMessage.style.color = 'inherit';
            }

            const csrfToken = getCsrfToken(); 
            if (!csrfToken) { 
                if (deleteStatusMessage) {
                    deleteStatusMessage.textContent = 'Error: CSRF token not found for AJAX delete.';
                    deleteStatusMessage.style.color = 'red';
                }
                return; 
            }
            fetch(deleteUrl, { method: 'POST', headers: { 'X-CSRFToken': csrfToken, 'Content-Type': 'application/json' } })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    const listItem = document.getElementById(`file-item-${fileId}`);
                    if (listItem) listItem.remove();
                    if (fileListContainer && fileListContainer.children.length === 0 && noFilesMessage) {
                        noFilesMessage.style.display = 'block';
                    }
                    if (deleteStatusMessage) {
                        deleteStatusMessage.textContent = data.message; 
                        deleteStatusMessage.style.color = 'green';
                        setTimeout(() => { if(deleteStatusMessage) deleteStatusMessage.textContent = ''; }, 3000);
                    }
                } else {
                    if (deleteStatusMessage) {
                        deleteStatusMessage.textContent = data.message || 'Failed to delete file.'; 
                        deleteStatusMessage.style.color = 'red';
                        setTimeout(() => { if(deleteStatusMessage) deleteStatusMessage.textContent = ''; }, 3000);
                    }
                }
            })
            .catch(error => { 
                if (deleteStatusMessage) {
                    deleteStatusMessage.textContent = 'A network error occurred during deletion.'; 
                    deleteStatusMessage.style.color = 'red'; 
                    setTimeout(() => { if(deleteStatusMessage) deleteStatusMessage.textContent = ''; }, 3000); 
                }
            });
        }
        
        if (fileListContainer) {
            fileListContainer.querySelectorAll('.file-delete-btn').forEach(button => {
                button.addEventListener('click', handleDeleteFileEvent);
            });
        }
    });
    </script>
    <script src="{% static 'wiki/JS/wiki_editor_enhancements.js' %}" defer></script>   
{% endblock %}