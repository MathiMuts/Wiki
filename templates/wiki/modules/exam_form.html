{% extends "./wiki_base.html" %}
{% block title%}{% if exam %}{{ exam.title }}{% else %}{{ action }} Exam{% endif %} - Wiki{% endblock %}
{% load static %}
{% block content %}
     <h1>{{ action }} Exam{% if parent_page %} for {{ parent_page.title }}: <strong class="page-meta"> {{ exam.title }}</strong>{% endif %}</h1>
    
    <form method="post" id="examPageForm" action=""> 
        {% csrf_token %}

        <div class="form-row-responsive">
            <div class="form-group form-group-responsive">
                <label for="{{ form.title.id_for_label }}">Title:</label>
                {{ form.title }}
                {% if form.title.errors %}<div class="form-field-error">{{ form.title.errors|join:", " }}</div>{% endif %}
            </div>

            <div class="form-group form-group-responsive">
                <label for="{{ form.slug.id_for_label }}">Slug (URL Path):</label>
                {{ form.slug }}
                {% if form.slug.errors %}<div class="form-field-error">{{ form.slug.errors|join:", " }}</div>{% endif %}
            </div>
        </div>

        <div class="form-group">
            <label for="{{ form.page_type.id_for_label }}">Content Type & PDF Method:</label>
            {{ form.page_type }} 
            {% if form.page_type.errors %}<div class="form-field-error">{{ form.page_type.errors|join:", " }}</div>{% endif %}
            <small id="pageTypeHelpText" class="form-text text-muted" style="display:none; color: var(--warning-color); margin-top: 5px;">
                Please select a content type above to enable the editor.
            </small>
        </div>

        <div class="form-group">
            <label for="{{ form.content.id_for_label }}">Content:</label>
            {{ form.content }}
            {% if form.content.errors %}<div class="form-field-error">{{ form.content.errors|join:", " }}</div>{% endif %}
        </div>
        
        <div class="actions edit-buttons">
            <div>
                <button type="submit" class="edit"> 
                    {% if action == 'Create' %}Create & Generate PDF{% else %}Save & Regenerate PDF{% endif %}
                </button>
                <a href="{{ parent_page.get_absolute_url }}" class="button-link cancel">Cancel</a>
            </div>
</form> 
        {% if exam and action == 'Edit' %}
            <form action="{% url 'wiki:exam_delete' parent_slug=parent_page.slug exam_slug=exam.slug %}" method="post" style="display: inline; margin: 0;" id="deleteForm">
                {% csrf_token %}
                <button type="button" class="delete hold-to-delete-btn" id="deleteBtn"
                        data-default-text="Delete This Exam" 
                        data-holding-text="Hold to Delete..." 
                        data-ready-text="Release to Delete!">
                    <span class="btn-text">Delete This Exam</span>
                    <span class="progress-fill"></span>
                </button>
            </form>
        {% endif %}
        </div>

    {% if exam and exam.pdf_file %}
        <hr style="margin: 2rem 0;">
        <h4>Current PDF:</h4>
        <p><a class="wikilink" href="{{ exam.pdf_file.url }}" target="_blank">{{ exam.pdf_file.name|cut:"wiki_exams/"|cut:parent_page.slug|cut:"/" }}</a></p>
    {% endif %}

<script>
    document.addEventListener('DOMContentLoaded', function() {
        function slugify_js(text) {
            if (!text) return '';
            return text.toString().toLowerCase()
                .replace(/\s+/g, '-')
                .replace(/[^\w-]+/g, '')
                .replace(/--+/g, '-')
                .replace(/^-+/, '')
                .replace(/-+$/, '');
        }

        const examTitleInput = document.getElementById('{{ form.title.id_for_label }}');
        const examSlugInput = document.getElementById('{{ form.slug.id_for_label }}');

        if (examTitleInput && examSlugInput) {
            examTitleInput.addEventListener('input', function() {
                if (examSlugInput.value === '' || examSlugInput.dataset.autoGenerated === 'true') {
                    const generatedSlug = slugify_js(this.value);
                    examSlugInput.value = generatedSlug;
                    examSlugInput.dataset.autoGenerated = 'true';
                }
            });
            examSlugInput.addEventListener('input', function() {
                this.dataset.autoGenerated = 'false';
            });
        }

        // --- Content Type Selector and Textarea Interaction ---
        const pageTypeSelect = document.getElementById('{{ form.page_type.id_for_label }}');
        const contentTextarea = document.getElementById('{{ form.content.id_for_label }}');
        const pageTypeHelpText = document.getElementById('pageTypeHelpText'); 

        // Store the original boilerplate to compare against
        const latexBoilerplate = `\\documentclass[oneside,a4paper,12pt,explicit]{article}
\\usepackage[accsupp]{axessibility}
\\usepackage[hidelinks]{hyperref}
\\usepackage[english, dutch]{babel}
\\usepackage{amsmath}
\\usepackage{url}
\\title{ Examen {{ parent_page.title|escapejs|default:"this exam" }} }
\\author{ {{ user.username|escapejs|default:"Een Wina Student" }} }
\\date{\\today}

\\begin{document}
\\maketitle

% Write your exam content here. Use LaTeX commands for formatting.

\\end{document}`;


        function normalizeWhitespace(str) {
            return str.replace(/\s+/g, ' ').trim();
        }
        const normalizedLatexBoilerplate = normalizeWhitespace(latexBoilerplate);
        let previousPageType = pageTypeSelect.value;

        if (pageTypeSelect && contentTextarea) {
            function handlePageTypeChange() {
                const selectedType = pageTypeSelect.value;
                const currentContent = contentTextarea.value;
                const normalizedCurrentContent = normalizeWhitespace(currentContent);

                if (selectedType === 'latex' || selectedType === 'markdown') {
                    contentTextarea.disabled = false;
                    contentTextarea.placeholder = 'Enter content here. PDF will be generated based on selected type.';
                    if (pageTypeHelpText) pageTypeHelpText.style.display = 'none';

                    if (selectedType === 'latex' && currentContent.trim() === '' {% if not exam %} && true {% else %} && false {% endif %}) {
                        contentTextarea.value = latexBoilerplate;
                        contentTextarea.dispatchEvent(new Event('input', { bubbles: true }));
                    }
                    else if (previousPageType === 'latex' && selectedType === 'markdown') {
                        if (normalizedCurrentContent === normalizedLatexBoilerplate) {
                            contentTextarea.value = '';
                            contentTextarea.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                    }

                } else {
                    contentTextarea.disabled = true;
                    contentTextarea.placeholder = 'Select a content type above to enable editing.';
                }
                previousPageType = selectedType;
            }

            handlePageTypeChange(); 
            pageTypeSelect.addEventListener('change', handlePageTypeChange);

            contentTextarea.addEventListener('click', function() {
                if (this.disabled && pageTypeHelpText) {
                    pageTypeHelpText.style.display = 'block';
                    pageTypeSelect.focus(); 
                    setTimeout(() => { 
                         if(pageTypeHelpText) pageTypeHelpText.style.display = 'none';
                    }, 4000);
                }
            });
        }

        if (contentTextarea) {
            let previousValue = contentTextarea.value;
            let previousCursorPos = contentTextarea.selectionStart;
            function getTrailingEmptyLineCount(text) { if (!text) return 0; const lines = text.split('\n'); let count = 0; for (let i = lines.length - 1; i >= 0; i--) { if (lines[i].trim() === "") { count++; } else { break; } } return count; }
            function autoResizeAndManageLines(event = null) {
                if (contentTextarea.disabled) return;
                const DESIRED_MINIMUM_TRAILING_EMPTY_LINES = 3;
                const currentValue = contentTextarea.value;
                const currentCursorPos = contentTextarea.selectionStart;
                let newCursorPos = currentCursorPos;
                let valueToProcess = currentValue;
                const savedScrollY = window.scrollY;
                const savedScrollX = window.scrollX;
                const existingTrailing = getTrailingEmptyLineCount(valueToProcess);
                const linesToAdd = DESIRED_MINIMUM_TRAILING_EMPTY_LINES - existingTrailing;

                if (linesToAdd > 0) {
                    const originalLengthBeforeAddingLines = valueToProcess.length;
                    for (let i = 0; i < linesToAdd; i++) { valueToProcess += '\n'; }
                    if (currentValue.length < valueToProcess.length && currentCursorPos === originalLengthBeforeAddingLines) {
                        newCursorPos = originalLengthBeforeAddingLines;
                    }
                }

                if (contentTextarea.value !== valueToProcess) {
                    contentTextarea.value = valueToProcess;
                }
                contentTextarea.style.height = 'auto';
                contentTextarea.style.height = (contentTextarea.scrollHeight) + 'px';

                if (event || (valueToProcess.length !== currentValue.length && !event) ) {
                    if (event && event.inputType === 'insertLineBreak') { /* Potentially special handling */ }
                    try {
                        const textLength = contentTextarea.value.length;
                        if (newCursorPos > textLength) { newCursorPos = textLength; }
                        if (contentTextarea.selectionStart !== newCursorPos || contentTextarea.selectionEnd !== newCursorPos) {
                           contentTextarea.setSelectionRange(newCursorPos, newCursorPos);
                        }
                    } catch (e) {
                        const endPos = contentTextarea.value.length;
                        try { contentTextarea.setSelectionRange(endPos, endPos); } catch (e2) { /* ignore secondary error */ }
                    }
                }
                previousValue = contentTextarea.value;
                previousCursorPos = contentTextarea.selectionStart;

                Promise.resolve().then(() => {
                    if (window.scrollY !== savedScrollY || window.scrollX !== savedScrollX) {
                        window.scrollTo(savedScrollX, savedScrollY);
                    }
                });
            }
            if (!contentTextarea.disabled) {
                autoResizeAndManageLines();
            }
            previousValue = contentTextarea.value;
            previousCursorPos = contentTextarea.selectionStart;
            contentTextarea.addEventListener('input', autoResizeAndManageLines);

            if (typeof initializeWikiEditorEnhancements === 'function') {
                initializeWikiEditorEnhancements(contentTextarea, 4);
            } else {
                console.warn('initializeWikiEditorEnhancements function not found. Ensure wiki_editor_enhancements.js is loaded.');
            }
        }

        // --- Hold-to-Delete Button for Exam Page ---
        // (This section remains the same as before)
        const deleteBtn = document.getElementById('deleteBtn');
        const deleteExamPageSpecificForm = document.getElementById('deleteForm');

        if (deleteBtn && deleteExamPageSpecificForm) {
            const HOLD_DURATION_PAGE = 5000;
            let examPageActionTimeoutId = null;
            let examPageAnimationFrameId = null;
            let isHoldingExamPageDelete = false;

            const progressFillSpan = deleteBtn.querySelector('.progress-fill');
            const btnTextSpan = deleteBtn.querySelector('.btn-text');
            const defaultText = deleteBtn.dataset.defaultText || 'Delete This Exam';
            const holdingText = deleteBtn.dataset.holdingText || 'Hold to Delete...';
            const readyText = deleteBtn.dataset.readyText || 'Release to Delete!';


            const setButtonText = (textKey) => {
                if (!btnTextSpan) return;
                if (textKey === 'default') btnTextSpan.textContent = defaultText;
                else if (textKey === 'holding') btnTextSpan.textContent = holdingText;
                else if (textKey === 'ready') btnTextSpan.textContent = readyText;
            };
            setButtonText('default');

            const resetExamPageHoldState = (performNudge = false) => {
                clearTimeout(examPageActionTimeoutId);
                cancelAnimationFrame(examPageAnimationFrameId);
                examPageActionTimeoutId = null;
                examPageAnimationFrameId = null;
                deleteBtn.classList.remove('is-filling', 'is-ready-to-delete');
                setButtonText('default');
                
                const wasHolding = isHoldingExamPageDelete;
                isHoldingExamPageDelete = false;

                if (performNudge && progressFillSpan && wasHolding) {
                    progressFillSpan.style.transition = 'none';
                    progressFillSpan.style.width = '15%';
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            progressFillSpan.style.transition = 'width 0.3s ease-out';
                            progressFillSpan.style.width = '0%';
                        });
                    });
                } else if (progressFillSpan) {
                    progressFillSpan.style.transition = 'width 0.1s linear';
                    progressFillSpan.style.width = '0%';
                }
            };

            const startExamPageHold = (event) => {
                event.preventDefault();
                if (isHoldingExamPageDelete) return;
                isHoldingExamPageDelete = true;

                deleteBtn.classList.add('is-filling');
                if (progressFillSpan) {
                    progressFillSpan.style.transition = 'none';
                    progressFillSpan.style.width = '0%';
                }
                setButtonText('holding');

                const startTime = Date.now();
                function animateExamPageFill() {
                    if (!isHoldingExamPageDelete) {
                        cancelAnimationFrame(examPageAnimationFrameId);
                        return;
                    }
                    const elapsedTime = Date.now() - startTime;
                    const progress = Math.min(100, (elapsedTime / HOLD_DURATION_PAGE) * 100);
                    if (progressFillSpan) progressFillSpan.style.width = progress + '%';

                    if (elapsedTime < HOLD_DURATION_PAGE) {
                        examPageAnimationFrameId = requestAnimationFrame(animateExamPageFill);
                    } else {
                        if (!deleteBtn.classList.contains('is-ready-to-delete')) {
                            deleteBtn.classList.add('is-ready-to-delete');
                            setButtonText('ready');
                        }
                    }
                }
                examPageAnimationFrameId = requestAnimationFrame(animateExamPageFill);

                examPageActionTimeoutId = setTimeout(() => {
                    if (isHoldingExamPageDelete) {
                        deleteBtn.classList.add('is-ready-to-delete');
                        setButtonText('ready');
                    }
                }, HOLD_DURATION_PAGE);
            };

            const endExamPageHold = (isReleasedOnButtonContext) => {
                if (!isHoldingExamPageDelete) return;

                const wasReadyForDelete = deleteBtn.classList.contains('is-ready-to-delete');
                const currentlyWasHolding = isHoldingExamPageDelete; 

                if (isReleasedOnButtonContext && wasReadyForDelete) {
                    isHoldingExamPageDelete = false;
                   if (confirm('Are you sure you want to delete this exam: \'{{ exam.title|escapejs|default:"this exam" }}\'? This action cannot be undone.')) {
                        deleteExamPageSpecificForm.submit();
                        return;
                    } else {
                        resetExamPageHoldState(false);
                    }
                } else if (isReleasedOnButtonContext && !wasReadyForDelete && currentlyWasHolding) {
                    resetExamPageHoldState(true);
                } else {
                    resetExamPageHoldState(false);
                }
            };
            
            deleteBtn.addEventListener('mousedown', startExamPageHold);
            deleteBtn.addEventListener('touchstart', (e) => startExamPageHold(e), { passive: false });
            
            deleteBtn.addEventListener('mouseleave', (event) => {
                if(isHoldingExamPageDelete && event.buttons === 1) {
                    // Do nothing, let mouseup handle it if button still pressed
                } else if (isHoldingExamPageDelete) {
                    resetExamPageHoldState(false);
                }
            });
            deleteBtn.addEventListener('touchcancel', () => { if(isHoldingExamPageDelete) resetExamPageHoldState(false); });
            deleteBtn.addEventListener('blur', () => { if(isHoldingExamPageDelete) resetExamPageHoldState(false); });
            
            document.addEventListener('mouseup', (event) => {
                if (isHoldingExamPageDelete) {
                    const isReleasedOnButton = event.target === deleteBtn || deleteBtn.contains(event.target);
                    endExamPageHold(isReleasedOnButton);
                }
            });
            document.addEventListener('touchend', (event) => {
                 if (isHoldingExamPageDelete) {
                    let isReleasedOnButton = false;
                    for (let i = 0; i < event.changedTouches.length; i++) {
                        const touch = event.changedTouches[i];
                        const endTarget = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (endTarget === deleteBtn || deleteBtn.contains(endTarget)) {
                            isReleasedOnButton = true;
                            break;
                        }
                    }
                    endExamPageHold(isReleasedOnButton);
                }
            });
        }
    });
    </script>
    <script src="{% static 'wiki/JS/wiki_editor_enhancements.js' %}" defer></script>
{% endblock %}